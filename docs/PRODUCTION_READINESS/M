# Monitoring Setup Guide

## Overview

This comprehensive monitoring guide outlines the complete observability stack for the OffScreen Buddy application, covering metrics, logging, tracing, alerting, and performance monitoring across all system components.

## Monitoring Architecture Overview

### Observability Stack Components
```
┌─────────────────────────────────────────┐
│           Application Layer             │
│  ┌─────────────────────────────────┐   │
│  │      Custom Metrics              │   │
│  │      Business Metrics            │   │
│  │      User Analytics              │   │
│  └─────────────────────────────────┘   │
├─────────────────────────────────────────┤
│           Infrastructure Layer          │
│  ┌─────────────────────────────────┐   │
│  │      System Metrics              │   │
│  │      Network Metrics             │   │
│  │      Container Metrics           │   │
│  └─────────────────────────────────┘   │
├─────────────────────────────────────────┤
│           Data Layer                    │
│  ┌─────────────────────────────────┐   │
│  │      Database Metrics            │   │
│  │      Cache Metrics               │   │
│  │      Message Queue Metrics       │   │
│  └─────────────────────────────────┘   │
├─────────────────────────────────────────┤
│           Monitoring Tools              │
│  ┌─────────────────────────────────┐   │
│  │      Prometheus                  │   │
│  │      Grafana                     │   │
│  │      Jaeger                      │   │
│  │      ELK Stack                   │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### Monitoring Principles
1. **Observability First**: Design for observability from the beginning
2. **Actionable Alerts**: Every alert should require action
3. **Proactive Monitoring**: Detect issues before users are affected
4. **Cost Awareness**: Optimize monitoring costs without sacrificing coverage
5. **Security Integration**: Monitor security events alongside performance
6. **Compliance Ready**: Maintain audit trails and compliance reporting

## Prometheus Monitoring Setup

### Prometheus Configuration
```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    cluster: 'offscreen-buddy'
    environment: 'production'

rule_files:
  - "alert_rules.yml"
  - "recording_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  # Application metrics
  - job_name: 'offscreen-api'
    static_configs:
      - targets: ['api-service:3000']
    scrape_interval: 10s
    metrics_path: /metrics
    scrape_timeout: 5s

  # Database metrics
  - job_name: 'postgres-exporter'
    static_configs:
      - targets: ['postgres-exporter:9187']
    scrape_interval: 30s

  # Redis metrics
  - job_name: 'redis-exporter'
    static_configs:
      - targets: ['redis-exporter:9121']
    scrape_interval: 30s

  # Node metrics
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
    scrape_interval: 30s

  # Kubernetes metrics (if using K8s)
  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)

  # Mobile app metrics (custom)
  - job_name: 'mobile-app-metrics'
    static_configs:
      - targets: ['mobile-metrics-collector:8080']
    scrape_interval: 60s
```

### Custom Metrics Implementation
```typescript
// monitoring/custom-metrics.ts
import { register, Counter, Histogram, Gauge } from 'prom-client';

// Define custom metrics
export const apiRequestDuration = new Histogram({
  name: 'api_request_duration_seconds',
  help: 'Duration of API requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]
});

export const activeUsers = new Gauge({
  name: 'active_users_total',
  help: 'Total number of active users',
  labelNames: ['time_window']
});

export const milestonesCreated = new Counter({
  name: 'milestones_created_total',
  help: 'Total number of milestones created',
  labelNames: ['user_type', 'category']
});

export const notificationDelivery = new Counter({
  name: 'notifications_delivered_total',
  help: 'Total number of notifications delivered',
  labelNames: ['channel', 'status', 'priority']
});

export const databaseQueryDuration = new Histogram({
  name: 'database_query_duration_seconds',
  help: 'Duration of database queries in seconds',
  labelNames: ['operation', 'table'],
  buckets: [0.01, 0.05, 0.1, 0.3, 0.5, 1, 2, 5]
});

export const errorRate = new Gauge({
  name: 'error_rate_ratio',
  help: 'Ratio of errors to total requests',
  labelNames: ['service', 'endpoint']
});

// Metrics collection utility
export class MetricsCollector {
  static recordAPICall(
    method: string,
    route: string,
    statusCode: number,
    duration: number
  ): void {
    apiRequestDuration
      .labels(method, route, statusCode.toString())
      .observe(duration);
  }

  static recordDatabaseQuery(
    operation: string,
    table: string,
    duration: number
  ): void {
    databaseQueryDuration
      .labels(operation, table)
      .observe(duration);
  }

  static updateActiveUsers(window: string, count: number): void {
    activeUsers.labels(window).set(count);
  }

  static incrementMilestone(
    userType: string,
    category: string
  ): void {
    milestonesCreated.labels(userType, category).inc();
  }

  static recordNotification(
    channel: string,
    status: string,
    priority: string
  ): void {
    notificationDelivery.labels(channel, status, priority).inc();
  }

  static updateErrorRate(
    service: string,
    endpoint: string,
    errorRate: number
  ): void {
    errorRate.labels(service, endpoint).set(errorRate);
  }
}

// Express middleware for automatic metrics collection
export const metricsMiddleware = (
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): void => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    
    MetricsCollector.recordAPICall(
      req.method,
      req.route?.path || req.path,
      res.statusCode,
      duration
    );
  });

  next();
};
```

### Mobile App Metrics
```typescript
// monitoring/mobile-metrics.ts
import { Counter, Histogram, Gauge } from 'prom-client';

// Mobile-specific metrics
export const appStartTime = new Histogram({
  name: 'mobile_app_start_time_seconds',
  help: 'Time taken for app to start',
  labelNames: ['platform', 'device_type'],
  buckets: [0.5, 1, 2, 3, 5, 10, 15]
});

export const screenLoadTime = new Histogram({
  name: 'mobile_screen_load_time_seconds',
  help: 'Time taken to load screen',
  labelNames: ['screen_name', 'connection_type'],
  buckets: [0.1, 0.3, 0.5, 1, 2, 3, 5]
});

export const userEngagement = new Gauge({
  name: 'mobile_user_engagement_duration_seconds',
  help: 'Duration of user session',
  labelNames: ['user_type']
});

export const offlineActions = new Counter({
  name: 'mobile_offline_actions_total',
  help: 'Total number of actions performed offline',
  labelNames: ['action_type', 'sync_status']
});

export const batteryUsage = new Gauge({
  name: 'mobile_battery_usage_percent',
  help: 'Current battery usage percentage',
  labelNames: ['device_model', 'app_version']
});

// React Native metrics collection
export class MobileMetricsCollector {
  static recordAppStart(
    platform: string,
    deviceType: string,
    startTime: number
  ): void {
    appStartTime
      .labels(platform, deviceType)
      .observe(startTime);
  }

  static recordScreenLoad(
    screenName: string,
    connectionType: string,
    loadTime: number
  ): void {
    screenLoadTime
      .labels(screenName, connectionType)
      .observe(loadTime);
  }

  static updateUserEngagement(
    userType: string,
    engagementDuration: number
  ): void {
    userEngagement
      .labels(userType)
      .set(engagementDuration);
  }

  static recordOfflineAction(
    actionType: string,
    syncStatus: string
  ): void {
    offlineActions
      .labels(actionType, syncStatus)
      .inc();
  }

  static updateBatteryUsage(
    deviceModel: string,
    appVersion: string,
    batteryPercent: number
  ): void {
    batteryUsage
      .labels(deviceModel, appVersion)
      .set(batteryPercent);
  }
}
```

## Grafana Dashboard Configuration

### Main Application Dashboard
```json
{
  "dashboard": {
    "id": null,
    "title": "OffScreen Buddy - Main Dashboard",
    "tags": ["offscreen-buddy", "main"],
    "timezone": "UTC",
    "refresh": "30s",
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "panels": [
      {
        "id": 1,
        "title": "API Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(api_request_duration_seconds_count[5m])",
            "legendFormat": "{{method}} {{route}}"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec"
          }
        ]
      },
      {
        "id": 2,
        "title": "API Response Time (P95)",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(api_request_duration_seconds_bucket[5m]))",
            "legendFormat": "{{method}} {{route}}"
          }
        ],
        "yAxes": [
          {
            "label": "Seconds"
          }
        ]
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(error_rate_ratio[5m]) * 100",
            "legendFormat": "{{service}} - {{endpoint}}"
          }
        ],
        "yAxes": [
          {
            "label": "Percentage"
          }
        ]
      },
      {
        "id": 4,
        "title": "Active Users",
        "type": "stat",
        "targets": [
          {
            "expr": "active_users_total{time_window=\"1h\"}",
            "legendFormat": "1h Active Users"
          },
          {
            "expr": "active_users_total{time_window=\"24h\"}",
            "legendFormat": "24h Active Users"
          }
        ]
      },
      {
        "id": 5,
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends",
            "legendFormat": "{{datname}}"
          }
        ]
      },
      {
        "id": 6,
        "title": "Redis Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "redis_memory_used_bytes / redis_memory_max_bytes * 100",
            "legendFormat": "Memory Usage %"
          }
        ]
      }
    ]
  }
}
```

### Business Metrics Dashboard
```json
{
  "dashboard": {
    "title": "OffScreen Buddy - Business Metrics",
    "panels": [
      {
        "title": "Daily Active Users",
        "type": "stat",
        "targets": [
          {
            "expr": "active_users_total{time_window=\"24h\"}",
            "legendFormat": "DAU"
          }
        ]
      },
      {
        "title": "Milestones Created Today",
        "type": "stat",
        "targets": [
          {
            "expr": "increase(milestones_created_total[24h])",
            "legendFormat": "Milestones Created"
          }
        ]
      },
      {
        "title": "User Retention Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(mobile_user_engagement_duration_seconds[24h]) / 86400 * 100",
            "legendFormat": "Retention %"
          }
        ]
      },
      {
        "title": "Notification Delivery Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(notifications_delivered_total{status=\"success\"}[5m]) / rate(notifications_delivered_total[5m]) * 100",
            "legendFormat": "{{channel}} Delivery Rate"
          }
        ]
      }
    ]
  }
}
```

### Infrastructure Dashboard
```json
{
  "dashboard": {
    "title": "OffScreen Buddy - Infrastructure",
    "panels": [
      {
        "title": "CPU Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "100 - (avg by(instance) (irate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)",
            "legendFormat": "{{instance}}"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100",
            "legendFormat": "{{instance}}"
          }
        ]
      },
      {
        "title": "Network I/O",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(node_network_receive_bytes_total[5m])",
            "legendFormat": "{{instance}} - RX"
          },
          {
            "expr": "rate(node_network_transmit_bytes_total[5m])",
            "legendFormat": "{{instance}} - TX"
          }
        ]
      },
      {
        "title": "Disk Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "100 - ((node_filesystem_avail_bytes * 100) / node_filesystem_size_bytes)",
            "legendFormat": "{{instance}} - {{mountpoint}}"
          }
        ]
      }
    ]
  }
}
```

## Alert Manager Configuration

### Alert Rules
```yaml
# monitoring/alert_rules.yml
groups:
  - name: offscreen.rules
    rules:
      # High API error rate
      - alert: HighAPIErrorRate
        expr: rate(api_request_duration_seconds_count{status_code=~"5.."}[5m]) / rate(api_request_duration_seconds_count[5m]) > 0.05
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High API error rate detected"
          description: "API error rate is {{ $value | humanizePercentage }} for service {{ $labels.service }}"

      # High response time
      - alert: HighAPIResponseTime
        expr: histogram_quantile(0.95, rate(api_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High API response time"
          description: "95th percentile response time is {{ $value }}s for {{ $labels.route }}"

      # Service down
      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
          description: "{{ $labels.job }} service is down"

      # High database connections
      - alert: HighDatabaseConnections
        expr: pg_stat_database_numbackends > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High number of database connections"
          description: "Database {{ $labels.datname }} has {{ $value }} connections"

      # Redis memory usage
      - alert: HighRedisMemoryUsage
        expr: redis_memory_used_bytes / redis_memory_max_bytes > 0.9
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High Redis memory usage"
          description: "Redis memory usage is {{ $value | humanizePercentage }}"

      # Low disk space
      - alert: LowDiskSpace
        expr: (node_filesystem_avail_bytes / node_filesystem_size_bytes) * 100 < 10
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Low disk space"
          description: "Disk usage is {{ $value }}% on {{ $labels.instance }} - {{ $labels.mountpoint }}"

      # High CPU usage
      - alert: HighCPUUsage
        expr: 100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 80
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage"
          description: "CPU usage is above 80% on {{ $labels.instance }}"

      # High memory usage
      - alert: HighMemoryUsage
        expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 85
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage"
          description: "Memory usage is above 85% on {{ $labels.instance }}"
```

### Alert Manager Configuration
```yaml
# monitoring/alertmanager.yml
global:
  smtp_smarthost: 'email-smtp.us-east-1.amazonaws.com:587'
  smtp_from: 'alerts@offscreen-buddy.com'
  slack_api_url: '${SLACK_WEBHOOK_URL}'

route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'
  routes:
    # Critical alerts
    - match:
        severity: critical
      receiver: 'critical-alerts'
      group_wait: 0s
      repeat_interval: 5m
    # Warning alerts
    - match:
        severity: warning
      receiver: 'warning-alerts'
      group_wait: 30s
      repeat_interval: 1h

receivers:
  - name: 'web.hook'
    webhook_configs:
      - url: 'http://alertmanager:9093/alert'

  - name: 'critical-alerts'
    email_configs:
      - to: 'oncall@offscreen-buddy.com'
        subject: 'CRITICAL: OffScreen Alert - {{ .GroupLabels.alertname }}'
        body: |
          {{ range .Alerts }}
          Alert: {{ .Annotations.summary }}
          Description: {{ .Annotations.description }}
          Labels: {{ range .Labels.SortedPairs }} - {{ .Name }}: {{ .Value }}{{ end }}
          {{ end }}
    slack_configs:
      - api_url: '${SLACK_WEBHOOK_URL}'
        channel: '#critical-alerts'
        title: 'Critical Alert - {{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
        send_resolved: true
    pagerduty_configs:
      - routing_key: '${PAGERDUTY_ROUTING_KEY}'
        description: '{{ .GroupLabels.alertname }} - {{ .GroupLabels.instance }}'

  - name: 'warning-alerts'
    email_configs:
      - to: 'devops@offscreen-buddy.com'
        subject: 'WARNING: OffScreen Alert - {{ .GroupLabels.alertname }}'
        body: |
          {{ range .Alerts }}
          Alert: {{ .Annotations.summary }}
          Description: {{ .Annotations.description }}
          Labels: {{ range .Labels.SortedPairs }} - {{ .Name }}: {{ .Value }}{{ end }}
          {{ end }}
    slack_configs:
      - api_url: '${SLACK_WEBHOOK_URL}'
        channel: '#alerts'
        title: 'Warning Alert - {{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}'
        send_resolved: true

inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'cluster', 'service']
```

## Distributed Tracing with Jaeger

### Jaeger Configuration
```yaml
# monitoring/jaeger-docker-compose.yml
version: '3.8'
services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # Jaeger UI
      - "14268:14268"  # HTTP collector
      - "14250:14250"  # gRPC collector
    environment:
      - COLLECTOR_ZIPKIN_HOST_PORT=:9411
    networks:
      - monitoring

  jaeger-agent:
    image: jaegertracing/jaeger-agent:latest
    ports:
      - "6831:6831/udp"
      - "6832:6832/udp"
    environment:
      - REPORTER_GRPC_HOST_PORT=jaeger:14250
    networks:
      - monitoring
```

### Tracing Implementation
```typescript
// monitoring/tracing.ts
import { initTracer } from 'jaeger-client';
import { Tags, FORMAT_HTTP_HEADERS } from 'opentracing';

export class TracingService {
  private tracer: any;

  constructor() {
    this.tracer = initTracer({
      serviceName: 'offscreen-buddy-api',
      reporter: {
        logSpans: true,
        agentHost: process.env.JAEGER_AGENT_HOST || 'localhost',
        agentPort: process.env.JAEGER_AGENT_PORT || 6832,
      },
      sampler: {
        type: 'const',
        param: 1,
      },
    }, {
      logger: console,
    });
  }

  // Create span for HTTP request
  createHTTPSpan(
    operationName: string,
    request: any,
    response: any
  ): any {
    const span = this.tracer.startSpan(operationName);
    
    // Add HTTP tags
    span.setTag(Tags.HTTP_METHOD, request.method);
    span.setTag(Tags.HTTP_URL, request.url);
    span.setTag(Tags.HTTP_STATUS_CODE, response.statusCode);
    
    // Add custom tags
    span.setTag('user.id', request.user?.id);
    span.setTag('request.id', request.id);
    
    return span;
  }

  // Create span for database operation
  createDBSpan(
    operationName: string,
    query: string,
    table: string,
    duration: number
  ): any {
    const span = this.tracer.startSpan(operationName);
    
    span.setTag(Tags.DB_TYPE, 'postgresql');
    span.setTag(Tags.DB_STATEMENT, query);
    span.setTag('db.table', table);
    span.setTag(Tags.DB_INSTANCE, process.env.DB_NAME);
    
    span.setTag('duration_ms', duration);
    
    return span;
  }

  // Create span for external API call
  createExternalAPISpan(
    operationName: string,
    service: string,
    endpoint: string,
    method: string
  ): any {
    const span = this.tracer.startSpan(operationName);
    
    span.setTag(Tags.PEER_SERVICE, service);
    span.setTag(Tags.PEER_HOSTNAME, endpoint);
    span.setTag(Tags.HTTP_METHOD, method);
    
    return span;
  }

  // Inject span context into headers
  injectSpanContext(span: any, headers: any): any {
    this.tracer.inject(span, FORMAT_HTTP_HEADERS, headers);
    return headers;
  }

  // Extract span context from headers
  extractSpanContext(headers: any): any {
    return this.tracer.extract(FORMAT_HTTP_HEADERS, headers);
  }
}
```

### Express Middleware for Tracing
```typescript
// monitoring/tracing-middleware.ts
export const tracingMiddleware = (tracingService: TracingService) => {
  return (req: express.Request, res: express.Response, next: express.NextFunction) => {
    const span = tracingService.createHTTPSpan(
      `${req.method} ${req.path}`,
      req,
      res
    );

    // Extract span context from incoming request
    const spanContext = tracingService.extractSpanContext(req.headers);
    if (spanContext) {
      span.setChildOf(spanContext);
    }

    // Add span to request for use in handlers
    req.span = span;

    // Add tracing headers to response
    tracingService.injectSpanContext(span, res.headers);

    // Finish span when response is sent
    res.on('finish', () => {
      span.finish();
    });

    next();
  };
};
```

### Database Query Tracing
```typescript
// monitoring/db-tracing.ts
export class DBCTracingWrapper {
  private tracingService: TracingService;

  constructor(tracingService: TracingService) {
    this.tracingService = tracingService;
  }

  async query(
    query: string,
    params: any[],
    table: string
  ): Promise<any> {
    const start = Date.now();
    const span = this.tracingService.createDBSpan(
      'database_query',
      query,
      table,
      0
    );

    try {
      const result = await this.executeQuery(query, params);
      
      span.setTag('db.rows_affected', result.rowCount || 0);
      span.setTag('db.success', true);
      
      return result;
    } catch (error) {
      span.setTag('db.success', false);
      span.setTag('error', true);
      span.setTag('error.message', error.message);
      throw error;
    } finally {
      const duration = Date.now() - start;
      span.setTag('duration_ms', duration);
      span.finish();
    }
  }

  private async executeQuery(query: string, params: any[]): Promise<any> {
    // Implement actual database query execution
    // This is a placeholder for the actual implementation
    return { rows: [], rowCount: 0 };
  }
}
```

## Log Management with ELK Stack

### Elasticsearch Configuration
```yaml
# monitoring/elasticsearch-docker-compose.yml
version: '3.8'
services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.8.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    networks:
      - monitoring

  logstash:
    image: docker.elastic.co/logstash/logstash:8.8.0
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf:ro
    ports:
      - "5000:5000"
      - "9600:9600"
    networks:
      - monitoring

  kibana:
    image: docker.elastic.co/kibana/kibana:8.8.0
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    ports:
      - "5601:5601"
    networks:
      - monitoring

volumes:
  elasticsearch-data:

networks:
  monitoring:
    driver: bridge
```

### Logstash Configuration
```ruby
# monitoring/logstash.conf
input {
  beats {
    port => 5044
  }
  
  tcp {
    port => 5000
    codec => json_lines
  }
}

filter {
  if [fields][log_type] == "application" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:logger} - %{GREEDYDATA:log_message}" }
    }
    
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
    }
    
    if [level] == "ERROR" {
      mutate {
        add_tag => [ "error" ]
      }
    }
    
    # Add application-specific fields
    if [message] =~ /user/ {
      mutate {
        add_field => { "category" => "user" }
      }
    }
    
    if [message] =~ /milestone/ {
      mutate {
        add_field => { "category" => "milestone" }
      }
    }
    
    if [message] =~ /notification/ {
      mutate {
        add_field => { "category" => "notification" }
      }
    }
  }
  
  # Security log processing
  if [fields][log_type] == "security" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} SECURITY %{DATA:event_type} %{GREEDYDATA:security_message}" }
    }
    
    if [event_type] == "login_failure" {
      mutate {
        add_field => { "severity" => "medium" }
      }
    }
    
    if [event_type] == "unauthorized_access" {
      mutate {
        add_field => { "severity" => "high" }
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "offscreen-buddy-%{+YYYY.MM.dd}"
  }
  
  # Error alerts
  if "error" in [tags] {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      format => "json"
      mapping => {
        "alerts" => [{
          "labels" => {
            "alertname" => "ApplicationError"
            "severity" => "warning"
            "service" => "offscreen-buddy"
            "message" => "%{log_message}"
          }
        }]
      }
    }
  }
  
  # Debug output for development
  stdout {
    codec => rubydebug
  }
}
```

### Structured Logging Implementation
```typescript
// monitoring/structured-logging.ts
import winston from 'winston';

export class StructuredLogger {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json(),
        winston.format.printf(({ timestamp, level, message, ...meta }) => {
          return JSON.stringify({
            timestamp,
            level,
            message,
            ...meta
          });
        })
      ),
      transports: [
        new winston.transports.Console(),
        new winston.transports.File({ 
          filename: 'logs/error.log', 
          level: 'error' 
        }),
        new winston.transports.File({ 
          filename: 'logs/combined.log' 
        })
      ]
    });
  }

  // Application logging
  logAPICall(
    method: string,
    route: string,
    statusCode: number,
    duration: number,
    userId?: string
  ): void {
    this.logger.info('API call completed', {
      event: 'api_call',
      method,
      route,
      status_code: statusCode,
      duration_ms: duration,
      user_id: userId
    });
  }

  // Database logging
  logDatabaseQuery(
    operation: string,
    table: string,
    duration: number,
    rowsAffected: number
  ): void {
    this.logger.info('Database query executed', {
      event: 'database_query',
      operation,
      table,
      duration_ms: duration,
      rows_affected: rowsAffected
    });
  }

  // User action logging
  logUserAction(
    action: string,
    userId: string,
    details?: any
  ): void {
    this.logger.info('User action performed', {
      event: 'user_action',
      action,
      user_id: userId,
      details
    });
  }

  // Security logging
  logSecurityEvent(
    eventType: string,
    userId: string,
    ipAddress: string,
    userAgent: string,
    success: boolean
  ): void {
    const level = success ? 'info' : 'warn';
    
    this.logger.log(level, 'Security event occurred', {
      event: 'security_event',
      event_type: eventType,
      user_id: userId,
      ip_address: ipAddress,
      user_agent: userAgent,
      success
    });
  }

  // Error logging with context
  logError(
    error: Error,
    context: string,
    additionalInfo?: any
  ): void {
    this.logger.error('Application error', {
      event: 'application_error',
      error_message: error.message,
      error_stack: error.stack,
      context,
      ...additionalInfo
    });
  }

  // Business metrics logging
  logBusinessEvent(
    event: string,
    userId: string,
    data: any
  ): void {
    this.logger.info('Business event', {
      event: 'business_event',
      business_event: event,
      user_id: userId,
      data
    });
  }
}
```

### Filebeat Configuration
```yaml
# monitoring/filebeat.yml
filebeat.inputs:
  - type: log
    enabled: true
    paths:
      - /var/log/offscreen-buddy/*.log
    fields:
      log_type: application
    fields_under_root: true
    multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'
    multiline.negate: true
    multiline.match: after

  - type: log
    enabled: true
    paths:
      - /var/log/nginx/*.log
    fields:
      log_type: nginx
    fields_under_root: true

  - type: log
    enabled: true
    paths:
      - /var/log/audit/*.log
    fields:
      log_type: security
    fields_under_root: true

output.logstash:
  hosts: ["logstash:5044"]

processors:
  - add_host_metadata:
      when.not.contains.tags: forwarded
  - add_cloud_metadata: ~
  - add_docker_metadata: ~

logging.level: info
logging.to_files: true
logging.files:
  path: /var/log/filebeat
  name: filebeat
  keepfiles: 7
  permissions: 0644
```

## Business Intelligence and Analytics

### Custom Analytics Implementation
```typescript
// monitoring/analytics.ts
export class AnalyticsService {
  async trackUserEngagement(userId: string, event: string, properties: any): Promise<void> {
    const analyticsEvent = {
      userId,
      event,
      properties,
      timestamp: new Date(),
      sessionId: await this.getSessionId(userId),
      deviceInfo: await this.getDeviceInfo(userId),
      location: await this.getUserLocation(userId)
    };

    // Store in analytics database
    await this.storeAnalyticsEvent(analyticsEvent);

    // Real-time processing
    await this.processRealTimeEvent(analyticsEvent);
  }

  async trackConversion(
    userId: string,
    conversionType: string,
    value: number,
    metadata?: any
  ): Promise<void> {
    const conversionEvent = {
      userId,
      conversionType,
      value,
      timestamp: new Date(),
      metadata,
      attribution: await this.getAttributionData(userId)
    };

    await this.storeConversionEvent(conversionEvent);
    await this.updateConversionMetrics(conversionEvent);
  }

  async trackFeatureUsage(
    feature: string,
    userId: string,
    usage: any
  ): Promise<void> {
    const featureUsage = {
      feature,
      userId,
      usage,
      timestamp: new Date(),
      version: process.env.APP_VERSION,
      platform: await this.getUserPlatform(userId)
    };

    await this.storeFeatureUsage(featureUsage);
    await this.updateFeatureMetrics(feature, featureUsage);
  }

  // A/B Testing
  async assignToABTest(
    userId: string,
    experimentName: string
  ): Promise<ABTestAssignment> {
    const assignment = await this.determineABTestAssignment(
      userId,
      experimentName
    );

    await this.recordABTestAssignment(userId, experimentName, assignment);
    
    return assignment;
  }

  // Cohort Analysis
  async generateCohortAnalysis(
    startDate: Date,
    endDate: Date,
    cohortType: 'registration' | 'milestone_first' | 'subscription'
  ): Promise<CohortAnalysis> {
    return await this.db.query(`
      WITH cohorts AS (
        SELECT 
          user_id,
          DATE_TRUNC('${cohortType}', created_at) as cohort_date,
          created_at
        FROM users
        WHERE created_at BETWEEN $1 AND $2
      ),
      retention AS (
        SELECT 
          c.cohort_date,
          DATE_TRUNC('week', u.created_at) as activity_week,
          COUNT(DISTINCT u.user_id) as active_users
        FROM cohorts c
        JOIN users u ON c.user_id = u.user_id
        WHERE u.created_at >= c.cohort_date
        GROUP BY c.cohort_date, DATE_TRUNC('week', u.created_at)
      )
      SELECT 
        cohort_date,
        activity_week,
        active_users,
        LAG(active_users) OVER (PARTITION BY cohort_date ORDER BY activity_week) as previous_week_users
      FROM retention
      ORDER BY cohort_date, activity_week
    `, [startDate, endDate]);
  }
}
```

### Performance Analytics
```typescript
// monitoring/performance-analytics.ts
export class PerformanceAnalytics {
  async trackPerformanceMetrics(): Promise<void> {
    const metrics = {
      timestamp: new Date(),
      applicationMetrics: await this.getApplicationMetrics(),
      infrastructureMetrics: await this.getInfrastructureMetrics(),
      userExperienceMetrics: await this.getUserExperienceMetrics(),
      businessMetrics: await this.getBusinessMetrics()
    };

    await this.storePerformanceMetrics(metrics);
    await this.checkPerformanceThresholds(metrics);
    await this.generatePerformanceInsights(metrics);
  }

  private async getUserExperienceMetrics(): Promise<UserExperienceMetrics> {
    return {
      // Frontend performance
      averagePageLoadTime: await this.getAveragePageLoadTime(),
      timeToFirstByte: await this.getTimeToFirstByte(),
      firstContentfulPaint: await this.getFirstContentfulPaint(),
      largestContentfulPaint: await this.getLargestContentfulPaint(),
      cumulativeLayoutShift: await this.getCumulativeLayoutShift(),
      firstInputDelay: await this.getFirstInputDelay(),
      
      // Mobile performance
      appStartupTime: await this.getAppStartupTime(),
      screenTransitionTime: await this.getScreenTransitionTime(),
      networkLatency: await this.getNetworkLatency(),
      
      // User satisfaction
      userSatisfactionScore: await this.getUserSatisfactionScore(),
      errorRate: await this.getErrorRate(),
      crashRate: await this.getCrashRate()
    };
  }

  private async getAveragePageLoadTime(): Promise<number> {
    // Implementation to calculate average page load time
    return 1.2; // seconds
  }

  // Performance insights generation
  private async generatePerformanceInsights(
    metrics: PerformanceMetrics
  ): Promise<PerformanceInsight[]> {
    const insights: PerformanceInsight[] = [];

    // Check for performance degradation
    if (metrics.userExperienceMetrics.averagePageLoadTime > 2.0) {
      insights.push({
        type: 'performance_degradation',
        severity: 'warning',
        message: 'Average page load time has increased',
        metric: 'page_load_time',
        value: metrics.userExperienceMetrics.averagePageLoadTime,
        threshold: 2.0,
        recommendation: 'Consider optimizing bundle size and implementing lazy loading'
      });
    }

    // Check for high error rate
    if (metrics.userExperienceMetrics.errorRate > 0.05) {
      insights.push({
        type: 'high_error_rate',
        severity: 'critical',
        message: 'Error rate is above acceptable threshold',
        metric: 'error_rate',
        value: metrics.userExperienceMetrics.errorRate,
        threshold: 0.05,
        recommendation: 'Investigate recent changes and implement better error handling'
      });
    }

    return insights;
  }
}
```

## Monitoring Dashboard Templates

### Real-time Operations Dashboard
```json
{
  "dashboard": {
    "title": "OffScreen Buddy - Real-time Operations",
    "refresh": "5s",
    "panels": [
      {
        "title": "Current Active Users",
        "type": "stat",
        "targets": [
          {
            "expr": "active_users_total{time_window=\"5m\"}",
            "legendFormat": "Active Users (5m)"
          }
        ],
        "thresholds": [
          {"color": "red", "value": 0},
          {"color": "green", "value": 1}
        ]
      },
      {
        "title": "Requests per Second",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(api_request_duration_seconds_count[1m])",
            "legendFormat": "RPS"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(api_request_duration_seconds_count{status_code=~\"4..|5..\"}[1m]) / rate(api_request_duration_seconds_count[1m]) * 100",
            "legendFormat": "Error %"
          }
        ]
      },
      {
        "title": "Response Time (P95)",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(api_request_duration_seconds_bucket[1m])) * 1000",
            "legendFormat": "Response Time (ms)"
          }
        ]
      },
      {
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends",
            "legendFormat": "{{datname}}"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100",
            "legendFormat": "{{instance}}"
          }
        ]
      }
    ]
  }
}
```

### Business Intelligence Dashboard
```json
{
  "dashboard": {
    "title": "OffScreen Buddy - Business Intelligence",
    "refresh": "1h",
    "panels": [
      {
        "title": "Daily Active Users (30 days)",
        "type": "graph",
        "targets": [
          {
            "expr": "increase(active_users_total{time_window=\"24h\"}[24h])",
            "legendFormat": "DAU"
          }
        ]
      },
      {
        "title": "User Acquisition",
        "type": "graph",
        "targets": [
          {
            "expr": "increase(user_registrations_total[24h])",
            "legendFormat": "New Users"
          }
        ]
      },
      {
        "title": "Feature Usage",
        "type": "table",
        "targets": [
          {
            "expr": "increase(feature_usage_total[7d])",
            "legendFormat": "{{feature}}"
          }
        ]
      },
      {
        "title": "Conversion Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(conversions_total[24h]) / rate(user_sessions_total[24h]) * 100",
            "legendFormat": "Conversion %"
          }
        ]
      },
      {
        "title": "User Retention (Weekly)",
        "type": "heatmap",
        "targets": [
          {
            "expr": "user_retention_rate",
            "legendFormat": "Week {{week}}"
          }
        ]
      }
    ]
  }
}
```

This comprehensive monitoring setup guide provides enterprise-grade observability for the OffScreen Buddy application with real-time metrics, alerting, distributed tracing, structured logging, and business intelligence capabilities.