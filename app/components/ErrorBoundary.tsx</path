import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Platform, Alert } from 'react-native';
import { 
  logger, 
  logError, 
  logWarn,
  logInfo,
  logUserAction, 
  logPerformance
} from '../utils/Logger';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
  enableRetry?: boolean;
  enableReporting?: boolean;
  retryLimit?: number;
  componentName?: string;
}

interface State {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
  retryCount: number;
  isReporting: boolean;
  errorId?: string;
  timestamp?: string;
}

// Error categories for better organization
const ERROR_CATEGORIES = {
  RENDERING: 'rendering',
  NETWORK: 'network',
  AUTHENTICATION: 'authentication',
  PAYMENT: 'payment',
  STORAGE: 'storage',
  NAVIGATION: 'navigation',
  BUSINESS_LOGIC: 'business_logic',
  SYSTEM: 'system',
  UNKNOWN: 'unknown'
} as const;

type ErrorCategory = typeof ERROR_CATEGORIES[keyof typeof ERROR_CATEGORIES];

class ErrorBoundary extends Component<Props, State> {
  private maxRetries: number;
  private performanceTimer?: number;
  private retryDelays = [1000, 3000, 5000]; // Exponential backoff

  constructor(props: Props) {
    super(props);
    this.maxRetries = props.retryLimit || 3;
    
    this.state = {
      hasError: false,
      error: undefined,
      errorInfo: undefined,
      retryCount: 0,
      isReporting: false
    };
  }

  static getDerivedStateFromError(error: Error): Partial<State> {
    return { 
      hasError: true, 
      error,
      timestamp: new Date().toISOString()
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const { onError, componentName, enableReporting = true } = this.props;
    
    // Generate unique error ID for tracking
    const errorId = this.generateErrorId();
    
    // Categorize the error
    const category = this.categorizeError(error, errorInfo);
    
    // Log the error with comprehensive context
    this.logError(error, errorInfo, category, errorId);
    
    // Track user action for analytics
    logUserAction('component_error', {
      componentName,
      category,
      errorId,
      retryCount: this.state.retryCount,
      timestamp: new Date().toISOString()
    });
    
    // Start performance tracking for error recovery
    this.startPerformanceTracking(errorId);
    
    // Call custom error handler if provided
    if (onError) {
      try {
        onError(error, errorInfo);
      } catch (handlerError) {
        logError('Custom error handler failed', { 
          originalError: error.message, 
          handlerError: handlerError instanceof Error ? handlerError.message : String(handlerError)
        });
      }
    }
    
    // Automatically report error in production (if enabled)
    if (enableReporting && __DEV__ === false) {
      this.reportError(error, errorInfo, category, errorId);
    }
    
    // Update state with error info
    this.setState({
      error,
      errorInfo,
      errorId
    });
  }

  componentWillUnmount() {
    if (this.performanceTimer) {
      clearTimeout(this.performanceTimer);
    }
  }

  /**
   * Categorize error based on error message and stack trace
   */
  private categorizeError(error: Error, errorInfo: ErrorInfo): ErrorCategory {
    const errorMessage = error.message.toLowerCase();
    const componentStack = errorInfo.componentStack?.toLowerCase() || '';
    
    // Network-related errors
    if (errorMessage.includes('network') || 
        errorMessage.includes('fetch') ||
        errorMessage.includes('connection') ||
        errorMessage.includes('timeout')) {
      return ERROR_CATEGORIES.NETWORK;
    }
    
    // Authentication errors
    if (errorMessage.includes('auth') || 
        errorMessage.includes('token') ||
        errorMessage.includes('permission') ||
        errorMessage.includes('unauthorized')) {
      return ERROR_CATEGORIES.AUTHENTICATION;
    }
    
    // Payment errors
    if (errorMessage.includes('payment') || 
        errorMessage.includes('transaction') ||
        errorMessage.includes('payu') ||
        errorMessage.includes('subscription')) {
      return ERROR_CATEGORIES.PAYMENT;
    }
    
    // Storage/AsyncStorage errors
    if (errorMessage.includes('storage') || 
        errorMessage.includes('asyncstorage') ||
        errorMessage.includes('localstorage')) {
      return ERROR_CATEGORIES.STORAGE;
    }
    
    // Navigation errors
    if (errorMessage.includes('navigation') || 
        errorMessage.includes('route') ||
        errorMessage.includes('router')) {
      return ERROR_CATEGORIES.NAVIGATION;
    }
    
    // Rendering errors (React-specific)
    if (errorMessage.includes('render') ||
        errorMessage.includes('virtualizedlist') ||
        componentStack.includes('render')) {
      return ERROR_CATEGORIES.RENDERING;
    }
    
    return ERROR_CATEGORIES.UNKNOWN;
  }

  /**
   * Log error with comprehensive context
   */
  private logError(error: Error, errorInfo: ErrorInfo, category: ErrorCategory, errorId: string) {
    const { componentName } = this.props;
    
    const errorContext = {
      errorId,
      category,
      componentName,
      errorMessage: error.message,
      errorStack: error.stack,
      componentStack: errorInfo.componentStack,
      retryCount: this.state.retryCount,
      timestamp: new Date().toISOString(),
      platform: Platform.OS,
      reactVersion: '19.1.0', // Would come from package.json
      appState: 'active', // Would come from AppState API
      memoryWarning: false // Would come from memory warnings
    };

    // Log based on error severity
    switch (category) {
      case ERROR_CATEGORIES.SYSTEM:
      case ERROR_CATEGORIES.PAYMENT:
        logError(`Critical error in ${componentName || 'component'}`, errorContext, error);
        break;
      case ERROR_CATEGORIES.NETWORK:
      case ERROR_CATEGORIES.AUTHENTICATION:
        logError(`High severity error in ${componentName || 'component'}`, errorContext, error);
        break;
      default:
        logWarn(`Error in ${componentName || 'component'}`, errorContext);
    }
  }

  /**
   * Start performance tracking for error recovery
   */
  private startPerformanceTracking(errorId: string) {
    const startTime = Date.now();
    
    this.performanceTimer = setTimeout(() => {
      const recoveryTime = Date.now() - startTime;
      
      logPerformance(`error_recovery_${errorId}`, recoveryTime, {
        errorId,
        category: 'error_recovery',
        success: !this.state.hasError
      });
    }, 5000); // Track recovery within 5 seconds
  }

  /**
   * Report error to external service (placeholder implementation)
   */
  private async reportError(error: Error, errorInfo: ErrorInfo, category: ErrorCategory, errorId: string) {
    if (this.state.isReporting) return;
    
    this.setState({ isReporting: true });
    
    try {
      // In a real implementation, this would send to crash reporting service
      const errorReport = {
        errorId,
        category,
        message: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack,
        timestamp: this.state.timestamp,
        platform: Platform.OS,
        appVersion: '1.0.0', // Would come from app config
        userId: 'anonymous' // Would come from auth context
      };
      
      logInfo('Error report prepared', { errorId, category });
      
      // Simulate API call
      // await fetch('/api/crash-reports', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify(errorReport)
      // });
      
    } catch (reportError) {
      logError('Failed to report error', { 
        originalError: error.message, 
        reportError: reportError instanceof Error ? reportError.message : String(reportError)
      });
    } finally {
      this.setState({ isReporting: false });
    }
  }

  /**
   * Handle retry with exponential backoff
   */
  handleRetry = () => {
    const { retryCount } = this.state;
    const { componentName } = this.props;
    
    if (retryCount < this.maxRetries) {
      // Calculate delay with exponential backoff
      const delay = this.retryDelays[Math.min(retryCount, this.retryDelays.length - 1)];
      
      logUserAction('error_retry_attempt', {
        componentName,
        retryCount: retryCount + 1,
        maxRetries: this.maxRetries,
        delay: `${delay}ms`
      });
      
      setTimeout(() => {
        this.setState(prevState => ({
          hasError: false,
          error: undefined,
          errorInfo: undefined,
          errorId: undefined,
          retryCount: prevState.retryCount + 1,
          timestamp: undefined
        }));
      }, delay);
      
    } else {
      // Max retries exceeded
      this.handleMaxRetriesExceeded();
    }
  };

  /**
   * Handle case when max retries are exceeded
   */
  private handleMaxRetriesExceeded() {
    const { componentName } = this.props;
    
    logUserAction('error_max_retries_exceeded', {
      componentName,
      maxRetries: this.maxRetries
    });
    
    if (Platform.OS === 'web') {
      // For web, show confirmation before reloading
      Alert.alert(
        'Restart Required',
        'The component has encountered repeated errors. Would you like to reload the page?',
        [
          { text: 'Cancel', style: 'cancel' },
          { text: 'Reload', onPress: () => window.location.reload() }
        ]
      );
    } else {
      // For native, suggest manual app restart
      Alert.alert(
        'App Restart Required',
        'The app encountered repeated errors. Please restart the app to continue.',
        [{ text: 'OK' }]
      );
    }
  }

  /**
   * Handle manual error reporting
   */
  handleReportError = () => {
    const { error, errorInfo, errorId } = this.state;
    
    if (error && errorInfo && errorId) {
      this.reportError(error, errorInfo, this.categorizeError(error, errorInfo), errorId);
      
      Alert.alert(
        'Error Reported',
        'Thank you for reporting this issue. Our team will investigate.',
        [{ text: 'OK' }]
      );
    }
  };

  /**
   * Generate unique error ID
   */
  private generateErrorId(): string {
    return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get error severity for UI display
   */
  private getErrorSeverity(category: ErrorCategory): 'low' | 'medium' | 'high' | 'critical' {
    switch (category) {
      case ERROR_CATEGORIES.SYSTEM:
      case ERROR_CATEGORIES.PAYMENT:
        return 'critical';
      case ERROR_CATEGORIES.NETWORK:
      case ERROR_CATEGORIES.AUTHENTICATION:
        return 'high';
      case ERROR_CATEGORIES.STORAGE:
      case ERROR_CATEGORIES.NAVIGATION:
        return 'medium';
      default:
        return 'low';
    }
  }

  /**
   * Get user-friendly error message
   */
  private getUserFriendlyMessage(category: ErrorCategory): string {
    switch (category) {
      case ERROR_CATEGORIES.NETWORK:
        return 'Unable to connect to the server. Please check your internet connection.';
      case ERROR_CATEGORIES.AUTHENTICATION:
        return 'There was an issue with authentication. Please try signing in again.';
      case ERROR_CATEGORIES.PAYMENT:
        return 'There was a problem processing your payment. Please try again.';
      case ERROR_CATEGORIES.STORAGE:
        return 'There was an issue saving your data. Please try again.';
      case ERROR_CATEGORIES.NAVIGATION:
        return 'There was a problem navigating. Please try again.';
      case ERROR_CATEGORIES.SYSTEM:
        return 'The app encountered a system error. Please restart the app.';
      default:
        return 'Something went wrong. Please try again.';
    }
  }

  render() {
    if (this.state.hasError && this.state.error) {
      const { 
        fallback, 
        componentName, 
        enableRetry = true, 
        enableReporting = true 
      } = this.props;
      
      const { error, retryCount, errorId, timestamp } = this.state;
      
      // Use custom fallback if provided
      if (fallback) {
        return fallback;
      }

      // Categorize error for UI
      const category = this.categorizeError(error, this.state.errorInfo!);
      const severity = this.getErrorSeverity(category);
      const userMessage = this.getUserFriendlyMessage(category);

      return (
        <View style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.emoji}>
              {severity === 'critical' ? 'üö®' : 
               severity === 'high' ? '‚ö†Ô∏è' : 
               severity === 'medium' ? 'üî∂' : 'üí°'}
            </Text>
            
            <Text style={styles.title}>
              {severity === 'critical' ? 'Critical Error' : 
               severity === 'high' ? 'Error Occurred' : 
               'Something Went Wrong'}
            </Text>
            
            <Text style={styles.message}>{userMessage}</Text>
            
            {__DEV__ && (
              <View style={styles.debugContainer}>
                <Text style={styles.debugTitle}>
                  Error Details (Debug Mode):
                </Text>
                <Text style={styles.debugText}>
                  ID: {errorId}
                </Text>
                <Text style={styles.debugText}>
                  Category: {category}
                </Text>
                <Text style={styles.debugText}>
                  Component: {componentName || 'Unknown'}
                </Text>
                <Text style={styles.debugText} numberOfLines={3}>
                  {error.message}
                </Text>
                {error.stack && (
                  <Text style={styles.debugStack} numberOfLines={5}>
                    {error.stack}
                  </Text>
                )}
                {timestamp && (
                  <Text style={styles.debugText}>
                    Time: {new Date(timestamp).toLocaleString()}
                  </Text>
                )}
              </View>
            )}
            
            <View style={styles.buttonContainer}>
              {enableRetry && (
                <TouchableOpacity
                  style={[
                    styles.retryButton,
                    retryCount >= this.maxRetries && styles.retryButtonDisabled
                  ]}
                  onPress={this.handleRetry}
                  activeOpacity={0.8}
                  disabled={retryCount >= this.maxRetries}
                >
                  <Text style={styles.retryButtonText}>
                    {retryCount < this.maxRetries 
                      ? `Try Again (${retryCount + 1}/${this.maxRetries})` 
                      : 'Restart App'
                    }
                  </Text>
                </TouchableOpacity>
              )}
              
              {enableReporting && (
                <TouchableOpacity
                  style={styles.reportButton}
                  onPress={this.handleReportError}
                  activeOpacity={0.8}
                  disabled={this.state.isReporting}
                >
                  <Text style={styles.reportButtonText}>
                    {this.state.isReporting ? 'Reporting...' : 'Report Issue'}
                  </Text>
                </TouchableOpacity>
              )}
            </View>
          </View>
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#FBF9F7',
  },
  content: {
    alignItems: 'center',
    maxWidth: 350,
  },
  emoji: {
    fontSize: 48,
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 12,
    color: '#2D2D2D',
    textAlign: 'center',
  },
  message: {
    fontSize: 14,
    textAlign: 'center',
    color: '#6B6B6B',
    marginBottom: 24,
    lineHeight: 20,
  },
  debugContainer: {
    backgroundColor: '#f5f5f5',
    padding: 12,
    borderRadius: 8,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#e0e0e0',
    maxWidth: 300,
  },
  debugTitle: {
    fontSize: 12,
    fontWeight: 'bold',
    color: '#666',
    marginBottom: 8,
  },
  debugText: {
    fontSize: 11,
    color: '#666',
    fontFamily: 'monospace',
    marginBottom: 4,
  },
  debugStack: {
    fontSize: 9,
    color: '#888',
    fontFamily: 'monospace',
    marginTop: 4,
  },
  buttonContainer: {
    gap: 12,
    alignItems: 'center',
  },
  retryButton: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
    minWidth: 140,
  },
  retryButtonDisabled: {
    backgroundColor: '#ccc',
  },
  retryButtonText: {
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  reportButton: {
    backgroundColor: 'transparent',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#007AFF',
    minWidth: 120,
  },
  reportButtonText: {
    color: '#007AFF',
    fontSize: 12,
    fontWeight: '500',
    textAlign: 'center',
  },
});

export default ErrorBoundary;
export type { ErrorCategory };